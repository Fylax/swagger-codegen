{{>licenseInfo}}

/* Do not edit this file manually */

{{#operations}}

#include "{{classname}}.h"
#include "{{classname}}Impl.h"

using namespace {{modelNamespace}};
using namespace {{apiNamespace}}::{{classname}}Impl;

#ifdef __cplusplus
extern "C" {
#endif

{{#operation}}
Response {{operationIdSnakeCase}}_handler(
  const char *name, const Key *keys,
  size_t num_keys {{#hasBodyParam}},
  const char *value{{/hasBodyParam}}) {
  {{#hasPathParams}}
  // Getting the path params{{#pathParams}}{{#vendorExtensions.x-is-cube-name}}
  std::string unique_name { name };{{/vendorExtensions.x-is-cube-name}}{{^vendorExtensions.x-is-cube-name}}
  {{dataType}} unique_{{paramName}};
  for (size_t i = 0; i < num_keys; ++i) {
    if (!strcmp(keys[i].name, "{{baseName}}")) { {{^isFloat}}{{^isDouble}}
      unique_{{paramName}} = {{#isString}}std::string { {{/isString}}keys[i].value.{{vendorExtensions.x-value-type}}{{#isString}} }{{/isString}};{{/isDouble}}{{/isFloat}}{{#isFloat}}
      unique_{{paramName}} = std::stof(keys[i].value.{{vendorExtensions.x-value-type}});{{/isFloat}}{{#isDouble}}
      unique_{{paramName}} = std::stod(keys[i].value.{{vendorExtensions.x-value-type}});{{/isDouble}}
      break;
    }
  }
  {{#isEnum}}
  auto unique_{{paramName}}_ = {{datatypeWithEnum}}::string_to_{{enumName}}(unique_{{paramName}});
  {{/isEnum}}
  {{/vendorExtensions.x-is-cube-name}}
  {{/pathParams}}
  {{/hasPathParams}}

  {{#vendorExtensions.x-is-list}}
  {{#hasBodyParam}}
  // Getting the body param
  {{#bodyParam}}
  {{{dataType}}} unique_{{paramName}}{{#isEnum}}_{{/isEnum}};
  {{/bodyParam}}
  {{/hasBodyParam}}
  {{/vendorExtensions.x-is-list}}

  try {
    {{#hasBodyParam}}
    {{#bodyParam}}
    auto request_body = nlohmann::json::parse(std::string { value });
    {{^isPrimitiveType}}
    {{#isListContainer}}
    {{^vendorExtensions.x-is-list}}
    // Getting the body param
    {{{dataType}}} unique_{{paramName}}{{#isEnum}}_{{/isEnum}};
    {{/vendorExtensions.x-is-list}}
    for (auto &j : request_body) {
      {{baseType}} a { j };
      unique_{{paramName}}{{#isEnum}}_{{/isEnum}}.push_back(a);
    }
    {{/isListContainer}}
    {{^isListContainer}}
    {{^vendorExtensions.x-is-list}}
    // Getting the body param
    {{{dataType}}} unique_{{paramName}} { request_body };
    {{/vendorExtensions.x-is-list}}{{#vendorExtensions.x-key-list}}
    unique_{{paramName}}.{{setter}}(unique_{{keyParamName}}{{#isEnum}}_{{/isEnum}});{{/vendorExtensions.x-key-list}}
    {{/isListContainer}}
    {{/isPrimitiveType}}
    {{#isPrimitiveType}}
    {{^isEnum}}
    // The conversion is done automatically by the json library
    {{{dataType}}} unique_{{paramName}} = request_body;
    {{/isEnum}}
    {{#isEnum}}
    {{{dataType}}} unique_{{paramName}}_ = {{vendorExtensions.x-enum-class}}::string_to_{{{dataType}}}(request_body);
    {{/isEnum}}
    {{/isPrimitiveType}}
    {{/bodyParam}}
    {{/hasBodyParam}}
    {{#returnType}}

    auto x = {{operationIdSnakeCase}}({{#allParams}}unique_{{paramName}}{{#isEnum}}_{{/isEnum}}{{#hasMore}}, {{/hasMore}}{{/allParams}});
    nlohmann::json response_body;
    {{#returnTypeIsPrimitive}}
    {{#returnSimpleType}}
    response_body = x;
    {{/returnSimpleType}}
    {{^returnSimpleType}}
    response_body = {{vendorExtensions.x-enum-class}}::{{returnType}}_to_string(x);
    {{/returnSimpleType}}
    {{/returnTypeIsPrimitive}}
    {{^returnTypeIsPrimitive}}
    {{#isListContainer}}
    for (auto &i : x) {
      response_body += i.toJson();
    }
    {{/isListContainer}}
    {{^isListContainer}}
    response_body = x.toJson();
    {{/isListContainer}}
    {{/returnTypeIsPrimitive}}
    return { k{{vendorExtensions.x-response-code}}, ::strdup(response_body.dump().c_str()) };
    {{/returnType}}
    {{^returnType}}
    {{operationIdSnakeCase}}({{#allParams}}unique_{{paramName}}{{#isEnum}}_{{/isEnum}}{{#hasMore}}, {{/hasMore}}{{/allParams}});
    return { k{{vendorExtensions.x-response-code}}, nullptr };
    {{/returnType}}
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

{{/operation}}

{{#operation}}
{{#vendorExtensions.x-needs-help}}
Response {{vendorExtensions.x-help-name}}_help(
  HelpType type, const char *name,
  const Key *keys, size_t num_keys) {
  {{#hasPathParams}}
  // Getting the path params{{#pathParams}}{{#vendorExtensions.x-is-cube-name}}
  std::string unique_name { name };{{/vendorExtensions.x-is-cube-name}}{{^vendorExtensions.x-is-cube-name}}
  {{dataType}} unique_{{paramName}};
  for (size_t i = 0; i < num_keys; ++i) {
    if (!strcmp(keys[i].name, "{{baseName}}")) { {{^isFloat}}{{^isDouble}}
      unique_{{paramName}} = {{#isString}}std::string { {{/isString}}keys[i].value.{{vendorExtensions.x-value-type}}{{#isString}} }{{/isString}};{{/isDouble}}{{/isFloat}}{{#isFloat}}
      unique_{{paramName}} = std::stof(keys[i].value.{{vendorExtensions.x-value-type}});{{/isFloat}}{{#isDouble}}
      unique_{{paramName}} = std::stod(keys[i].value.{{vendorExtensions.x-value-type}});{{/isDouble}}
      break;
    }
  }
  {{#isEnum}}
  auto unique_{{paramName}}_ = {{datatypeWithEnum}}::string_to_{{enumName}}(unique_{{paramName}});
  {{/isEnum}}
  {{/vendorExtensions.x-is-cube-name}}
  {{/pathParams}}
  {{/hasPathParams}}
  {{#vendorExtensions.x-is-list}}
  {{#hasBodyParam}}
  // Getting the body param
  {{#bodyParam}}
  {{{dataType}}} unique_{{paramName}}{{#isEnum}}_{{/isEnum}};
  {{/bodyParam}}
  {{/hasBodyParam}}
  {{/vendorExtensions.x-is-list}}

  nlohmann::json val = nlohmann::json::object();
  switch (type) {
  case HelpType::SHOW:
    {{#vendorExtensions.x-is-list}}
    val["params"] = {{returnBaseType}}JsonObject::helpKeys();
    val["elements"] = {{operationIdSnakeCase}}_get_list({{#allParams}}unique_{{paramName}}{{#isEnum}}_{{/isEnum}}{{#hasMore}}, {{/hasMore}}{{/allParams}});
    {{/vendorExtensions.x-is-list}}
    {{^vendorExtensions.x-is-list}}
    val["params"] = {{returnBaseType}}JsonObject::helpElements();
    {{/vendorExtensions.x-is-list}}
  break;{{#vendorExtensions.x-is-list}}
  case HelpType::ADD:
    val["params"] = {{returnBaseType}}JsonObject::helpKeys();
    val["optional-params"] = {{returnBaseType}}JsonObject::helpWritableLeafs();
  break;{{/vendorExtensions.x-is-list}}{{^vendorExtensions.x-is-list}}
  case HelpType::SET:
    val["params"] = {{returnBaseType}}JsonObject::helpWritableLeafs();
  break;{{/vendorExtensions.x-is-list}}{{#vendorExtensions.x-is-list}}
  case HelpType::DEL:
    val["params"] = {{returnBaseType}}JsonObject::helpKeys();
    val["elements"] = {{operationIdSnakeCase}}_get_list({{#allParams}}unique_{{paramName}}{{#isEnum}}_{{/isEnum}}{{#hasMore}}, {{/hasMore}}{{/allParams}});
  break;{{/vendorExtensions.x-is-list}}
  case HelpType::NONE:
    {{#vendorExtensions.x-is-list}}
    val["commands"] = {"add", "del", "show"};
    val["params"] = {{returnBaseType}}JsonObject::helpKeys();
    val["elements"] = {{operationIdSnakeCase}}_get_list({{#allParams}}unique_{{paramName}}{{#isEnum}}_{{/isEnum}}{{#hasMore}}, {{/hasMore}}{{/allParams}});
    {{/vendorExtensions.x-is-list}}
    {{^vendorExtensions.x-is-list}}
    val["commands"] = {"set", "show"};
    val["params"] = {{returnBaseType}}JsonObject::helpComplexElements();
    val["actions"] = {{returnBaseType}}JsonObject::helpActions();
    {{/vendorExtensions.x-is-list}}
  break;
  default:
    return { kBadRequest, nullptr };
  }
  return { kOk, ::strdup(val.dump().c_str()) };
}

{{/vendorExtensions.x-needs-help}}
{{/operation}}
{{#operation}}
{{#vendorExtensions.x-is-yang-action}}

Response {{vendorExtensions.x-help-name}}_help(
  HelpType type, const char *name,
  const Key *keys, size_t num_keys) {
  nlohmann::json val = nlohmann::json::object();
  {{#bodyParam}}
  {{^isPrimitiveType}}
  val["in"] = {{dataType}}::helpElements();
  {{/isPrimitiveType}}
  {{/bodyParam}}

  return { kOk, ::strdup(val.dump().c_str()) };
}
{{/vendorExtensions.x-is-yang-action}}
{{/operation}}
#ifdef __cplusplus
}
#endif

{{/operations}}
